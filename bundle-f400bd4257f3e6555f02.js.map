{"version":3,"file":"bundle-f400bd4257f3e6555f02.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxE6B;AAC7B;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uCAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACpCsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAe,CAAC,kDAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO,EAAE,yBAAyB;AAC9E;AACA,uBAAuB,OAAO,EAAE,yBAAyB,EAAE,UAAU;AACrE;AACA,2CAA2C,OAAO,EAAE,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://avl-tree/./src/arrays.js","webpack://avl-tree/./src/index.js","webpack://avl-tree/./src/tree.js"],"sourcesContent":["// Merge sort\r\n\r\n// Helper function to merge the arrays back into one sorted array\r\nfunction merge(leftArray, rightArray) {\r\n    let sortedArray = [];\r\n\r\n    while (leftArray.length && rightArray.length) {\r\n        if (leftArray[0] < rightArray[0]) {\r\n            sortedArray.push(leftArray.shift());\r\n        } else {\r\n            sortedArray.push(rightArray.shift())\r\n        }\r\n    }\r\n    \r\n    return [...sortedArray, ...leftArray, ...rightArray];\r\n};\r\n\r\n// Recursive function to split the array in 2 until array lengh is 1\r\nfunction mergeSort(array) {\r\n    if (array.length <= 1) {\r\n        return array;\r\n    } else {\r\n        let half = Math.floor(array.length / 2);\r\n        let leftArray = mergeSort(array.slice(0, half));\r\n        let rightArray = mergeSort(array.slice(half));\r\n        return merge(leftArray, rightArray);\r\n    }\r\n};\r\n\r\n// Check all values in an array\r\n// E.g.console.log(all([1,2,1], \r\n// function(num) { return num < 7 }))\r\n// returns true because all indexes in array satisfy the callback condition\r\nfunction all(array, callback) {\r\n    // Make a shallow copy of the array\r\n    let copy = array.slice();\r\n    // Base case\r\n    if (copy.length === 0) {\r\n        return true;\r\n    }\r\n\r\n    if (callback(copy[0])) {\r\n        copy.shift(); // remove first element from array\r\n        return all(copy, callback)\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n// Remove any duplicate integers from a sorted array\r\n\r\nfunction removeDuplicate(array) {\r\n    // Get the array length\r\n    const arrayLength = array.length\r\n    // Base case\r\n    if (arrayLength <= 1) { return array };\r\n    // Recursion case\r\n    let temp = [];\r\n\r\n    for (let i = 0; i < arrayLength; i++) {\r\n        // if this value is NOT a duplicate of the last value\r\n        if (array[i] != array[i-1]) {\r\n            // add this value to temp\r\n            temp.push(array[i]); \r\n        }\r\n    }\r\n    return temp;\r\n\r\n        \r\n}\r\n\r\n\r\n\r\nexport { mergeSort, removeDuplicate }","import { Tree } from './tree'\r\n\r\nfunction randomArray(num, max) {\r\n    const array = [];\r\n    for (let i = 0; i < num; i++) {\r\n        array.push(Math.floor(Math.random() * max));\r\n    }\r\n    return array;\r\n}\r\n\r\n(function driver() {\r\n    let array = randomArray(10, 20);\r\n    const tree = new Tree(array);\r\n    console.log('Your tree:');\r\n    tree.prettyPrint(tree.root);\r\n    console.log('Balanced? ' + tree.isBalanced(tree.root));\r\n\r\n    tree.insert(2);\r\n    tree.insert(8);\r\n    tree.insert(10);\r\n\r\n    console.log('Your tree with nodes added:');\r\n    tree.prettyPrint(tree.root);\r\n    console.log('Balanced? ' + tree.isBalanced(tree.root));\r\n\r\n    \r\n\r\n    console.log('Your tree rebalanced:');\r\n    tree.root = tree.rebalance();\r\n    tree.prettyPrint(tree.root);\r\n    console.log('Balanced? ' + tree.isBalanced(tree.root))\r\n\r\n    console.log('Inorder: ' + tree.inOrder(tree.root));\r\n    console.log('Preorder: ' + tree.preOrder(tree.root));\r\n    console.log('Postorder: ' + tree.postOrder(tree.root));\r\n})();\r\n\r\n","import { mergeSort, removeDuplicate } from './arrays';\r\n\r\nclass Node {\r\n    constructor(data) {\r\n        this.data = data || null;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n};\r\n\r\nclass Tree {\r\n    constructor(array) {\r\n        // Sort the array and remove duplicates\r\n        this.array = [...removeDuplicate(mergeSort(array))];\r\n        // build the root\r\n        this.root = this.buildTree(this.array, 0, this.array.length - 1);\r\n        this.inOrderData = [];\r\n        this.preOrderData = [];\r\n        this.postOrderData = [];\r\n    }\r\n\r\n    // Build the tree\r\n    buildTree(array, start, end) {\r\n        // Base case: if array has no values, return null\r\n        if (start > end) return null;\r\n\r\n        // Recursive case:\r\n        // Get the half-way index of the array\r\n        // Math.ceil() for left-leaning, Math.floor() for right-leaning\r\n        let half = Math.ceil((start + end) / 2);\r\n\r\n        // Set the root node to be the value at the index of half\r\n        let node = new Node(array[half]);\r\n\r\n        // Recursively call this method to build the next level of the tree\r\n        node.left = this.buildTree(array, start, half - 1);\r\n        node.right = this.buildTree(array, half + 1, end);\r\n        // Return the level-0 root node - the middle value of the array\r\n        return node;\r\n    }\r\n\r\n    // Insert a node\r\n    insert(value, root = this.root) {\r\n        if (root === null) return (root = new Node(value));\r\n        if (root.data < value) {\r\n            root.right = this.insert(value, root.right);\r\n        } else {\r\n            root.left = this.insert(value, root.left);\r\n        }\r\n        return root;\r\n    }\r\n\r\n    delete(value, root = this.root) {\r\n        if (root === null) return root;\r\n       \r\n        if (root.data > value) {\r\n            root.left = this.delete(value, root.left);\r\n        } else if (root.data < value) {\r\n            root.right = this.delete(value, root.right);\r\n        } else {\r\n            if (root.left == null) {\r\n                return root.right;\r\n            } else if (root.right == null) {\r\n                return root.left;\r\n            }\r\n            root.data = getMin(root);\r\n            root.right = this.delete(root.right, root.data);\r\n        }\r\n        return root;\r\n    }\r\n\r\n    find(value, root = this.root) {\r\n        if (root === null) return false;\r\n        // Get the Node with this value and return it\r\n        if (root.data === value) return root;\r\n        if (root.data > value) {\r\n            return this.find(value, root.left);\r\n        } else if (root.data > value) {\r\n            return this.find(value, root.right)\r\n        }\r\n        return root;\r\n    }\r\n\r\n    levelOrder(root) {\r\n        const queue = [];\r\n        const result = [];\r\n        if (root === null) return;\r\n        queue.push(root);\r\n        while (queue.length > 0) {\r\n            let current = queue.shift(root);\r\n            result.push(current.data);\r\n            if (current.left !== null) {\r\n                queue.push(current.left);\r\n            }\r\n            if (current.right !== null) {\r\n                queue.push(current.right);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    inOrder(root) {\r\n        if (root === null) return;\r\n        if (root.left !== null) {\r\n            this.inOrder(root.left);\r\n        }\r\n        if (root.data !== undefined) {\r\n            this.inOrderData.push(root.data);\r\n        }\r\n\r\n        if (root.right !== null) {\r\n            this.inOrder(root.right);\r\n        }\r\n        return this.inOrderData;\r\n    }\r\n\r\n    preOrder(root) {\r\n        if (root === null) return;\r\n        if (root.data !== undefined) {\r\n            this.preOrderData.push(root.data);\r\n        }\r\n        if (root.elft !== null) {\r\n            this.preOrder(root.left);\r\n        }\r\n        if (root.right !== null) {\r\n            this.preOrder(root.right);\r\n        }\r\n        return this.preOrderData;\r\n    }\r\n\r\n    postOrder(root) {\r\n        if (root === null) return;\r\n        if (root.left !== null) {\r\n            this.postOrder(root.left);\r\n        }\r\n        if (root.right !== null) {\r\n            this.postOrder(root.right);\r\n        }\r\n        if (root.data !== undefined) {\r\n            this.postOrderData.push(root.data);\r\n        }\r\n        return this.postOrderData;\r\n    }\r\n\r\n    height(root) {\r\n        if (root === null) {\r\n            return -1;\r\n        } else {\r\n            let left = this.height(root.left);\r\n            let right = this.height(root.right);\r\n            return Math.max(left, right) + 1;\r\n        }\r\n    }\r\n\r\n    depth(node, root = this.root) {\r\n        let depth = -1;\r\n        if (root === null) return depth;\r\n        if (root == node || \r\n            (depth = this.depth(node, root.left)) >= 0 ||\r\n            (depth = this.depth(node, root.right) >= 0)) {\r\n                return depth + 1;\r\n            }\r\n        return depth;\r\n    }\r\n\r\n    traverse(root, array) {\r\n        if (array !== undefined) {\r\n            array.push(root.data);\r\n        }\r\n        if (root.left !== null) {\r\n            this.traverse(root.left, array);\r\n        }\r\n        if (root.right !== null) {\r\n            this.traverse(root.right, array);\r\n        }\r\n        return array;\r\n    }\r\n\r\n    isBalanced(root) {\r\n        if (root === null) return false;\r\n        let leftHalf = root.left;\r\n        let rightHalf = root.right;\r\n\r\n        if (Math.abs(this.height(leftHalf) - this.height(rightHalf)) > 1) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    rebalance() {\r\n        if (this.isBalanced(this.root)) return this.root;\r\n        let rebalancedArray = [];\r\n        rebalancedArray = this.traverse(this.root, rebalancedArray);\r\n        let balancedTree = new Tree(rebalancedArray);\r\n        return balancedTree.root;\r\n    }\r\n\r\n    prettyPrint(root, prefix = '', isLeft = true) {\r\n        if (root.right !== null) {\r\n            this.prettyPrint(root.right, `${prefix}${isLeft ? '│   ' : '    '}`, false);\r\n        }\r\n        console.log(`${prefix}${isLeft ? '└── ' : '┌── '}${root.data}`);\r\n        if (root.left !== null) {\r\n            this.prettyPrint(root.left, `${prefix}${isLeft ? '    ' : '│   '}`, true);\r\n        }\r\n        \r\n    }\r\n};\r\n\r\nfunction getMin(root) {\r\n    let min = root.data;\r\n    while (root != null) {\r\n        min = root.data;\r\n        root = root.leftPart;\r\n    }\r\n    return min;\r\n}\r\n\r\nexport { Tree };"],"names":[],"sourceRoot":""}