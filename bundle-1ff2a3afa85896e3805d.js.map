{"version":3,"file":"bundle-1ff2a3afa85896e3805d.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wDAAe,CAAC,kDAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://avl-tree/./src/arrays.js","webpack://avl-tree/./src/index.js"],"sourcesContent":["// Merge sort\r\n\r\n// Helper function to merge the arrays back into one sorted array\r\nfunction merge(leftArray, rightArray) {\r\n    let sortedArray = [];\r\n\r\n    while (leftArray.length && rightArray.length) {\r\n        if (leftArray[0] < rightArray[0]) {\r\n            sortedArray.push(leftArray.shift());\r\n        } else {\r\n            sortedArray.push(rightArray.shift())\r\n        }\r\n    }\r\n    \r\n    return [...sortedArray, ...leftArray, ...rightArray];\r\n};\r\n\r\n// Recursive function to split the array in 2 until array lengh is 1\r\nfunction mergeSort(array) {\r\n    if (array.length <= 1) {\r\n        return array;\r\n    } else {\r\n        let half = Math.floor(array.length / 2);\r\n        let leftArray = mergeSort(array.slice(0, half));\r\n        let rightArray = mergeSort(array.slice(half));\r\n        return merge(leftArray, rightArray);\r\n    }\r\n};\r\n\r\n// Check all values in an array\r\n// E.g.console.log(all([1,2,1], \r\n// function(num) { return num < 7 }))\r\n// returns true because all indexes in array satisfy the callback condition\r\nfunction all(array, callback) {\r\n    // Make a shallow copy of the array\r\n    let copy = array.slice();\r\n    // Base case\r\n    if (copy.length === 0) {\r\n        return true;\r\n    }\r\n\r\n    if (callback(copy[0])) {\r\n        copy.shift(); // remove first element from array\r\n        return all(copy, callback)\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n// Remove any duplicate integers from a sorted array\r\n\r\nfunction removeDuplicate(array) {\r\n    // Get the array length\r\n    const arrayLength = array.length\r\n    // Base case\r\n    if (arrayLength <= 1) { return array };\r\n    // Recursion case\r\n    let temp = [];\r\n\r\n    for (let i = 0; i < arrayLength; i++) {\r\n        // if this value is NOT a duplicate of the last value\r\n        if (array[i] != array[i-1]) {\r\n            // add this value to temp\r\n            temp.push(array[i]); \r\n        }\r\n    }\r\n    return temp;\r\n\r\n        \r\n}\r\n\r\n\r\n\r\nexport { mergeSort, removeDuplicate }","import { mergeSort, removeDuplicate } from './arrays';\r\n\r\nclass Node {\r\n    constructor(data) {\r\n        this.data = data || null;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n};\r\n\r\nclass Tree {\r\n    constructor(array) {\r\n        this.root = this.buildTree(array);\r\n    }\r\n\r\n    // Build the tree\r\n    buildTree(array) {\r\n        // Sort the array and remove duplicates\r\n        let cleanedArray = removeDuplicate(mergeSort(array));\r\n        // Base case:\r\n        if (cleanedArray.length <= 1) {\r\n            let node = new Node(cleanedArray[0]);\r\n            return node;\r\n        }\r\n        // Recursive case:\r\n        // Turn the cleanedArray into a balanced binary tree of Nodes\r\n        let half = Math.floor(cleanedArray.length / 2);\r\n        let node = new Node(cleanedArray[half]);\r\n        let leftArray = cleanedArray.slice(0, half);\r\n        let rightArray = cleanedArray.slice(half);\r\n        node.left = this.buildTree(leftArray);\r\n        node.right = this.buildTree(rightArray);\r\n        // Return the level-0 root node - the middle value of the array\r\n        return node;\r\n    }\r\n\r\n    // Insert a node\r\n    insert(value) {\r\n        // Make a new Node with this value\r\n        const newNode = new Node(value);\r\n        // Insert the node in the correct place\r\n    }\r\n\r\n    delete(value) {\r\n        // Get the Node with this value\r\n\r\n        // Remove the Node (check for if it has children etc)\r\n    }\r\n\r\n    find(value) {\r\n        // Get the Node with this value and return it\r\n    }\r\n\r\n    levelOrder(callback) {\r\n        // Traverse the tree in a breadth-first level order\r\n        // and provide each Node as the argument to the\r\n        // provided callback function\r\n\r\n        // Return an array of values if no callback function is given\r\n    }\r\n};\r\n\r\n\r\n\r\nlet array = [1,5,3,9,3,4,9,11,245,6,6,9,3,4];\r\nconst tree = new Tree(array);\r\n\r\nconsole.log(tree);\r\n\r\n\r\n"],"names":[],"sourceRoot":""}